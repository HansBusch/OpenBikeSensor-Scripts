<!doctype html>
<html lang="en">

<!--
Copyright (C) 2020-2021 OpenBikeSensor Contributors
Contact: https://openbikesensor.org

This file is part of the OpenBikeSensor Scripts Collection.

The OpenBikeSensor Scripts Collection is free software: you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation, either version 3 of the License,
or (at your option) any later version.

The OpenBikeSensor Scripts Collection is distributed in the hope that it will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser
General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the OpenBikeSensor Scripts Collection.  If not, see
<http://www.gnu.org/licenses/>.
-->

<head>
	<meta charset="utf-8">
	<link rel="stylesheet"
		href="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/css/ol.css" type="text/css">
	<style>
		.map {
			position: absolute;
			width: 100%;
			height: 100%;
			left: 0px;
			top: 0px;
			z-index: 0;
		}

		.bw {
		    filter: grayscale(100%) opacity(50%);
		}

		.overlay {
			display: flex;
			flex-direction: column;
			justify-content: space-around;
			position: absolute;
			width: 30%;
			height: 98%;
			left: 1%;
			top: 1%;
			z-index: 0;
		}

		.title {
			display: flex;
			position: relative;
			height: 10%;
			width: 100%;
			background-color: #FFFFFF;
			padding: 5px;
			z-index: 0;
		}

		.title_image {
			height: 100%
		}

		.title_text {
			padding: 0px;
			height: 100%;
			vertical-align: middle;
			background-color: #FF8080;
		}

		.caption {
			display: flex;
			height: 20%;
			width: 100%;
			background-color: #FFFFFF;
			padding: 5px;
			align-items: center;
			z-index: 0;
		}

		.chart {
			width: 100%;
			height: 30%;
			background-color: #FFFFFF;
			padding: 5px;
			z-index: 0;
		}

		.legend {
			height: 15%;
			width: 100%;
			background-color: #FFFFFF;
			padding: 5px;
			z-index: 0;
		}

		.ol-zoom {
			left: unset;
			right: 8px;
		}
	</style>
	<script src="https://cdn.jsdelivr.net/gh/openlayers/openlayers.github.io@master/en/v6.4.3/build/ol.js"></script>
	<script src="https://cdn.jsdelivr.net/npm/apexcharts"></script>
	<script src="OBS.js"></script>
	<title>OpenBikeSensor Visualisierung: Stra&szlig;enabschnitte</title>
</head>

<body>
	<div id="map" class="map"></div>
	<div id="overlay" class="overlay">
		<div id="title" class="title">
			<div id="title_image"><img src="images/OBS.png" height="100%"></img></div>
			<div id="title_text">
				<h4>Visualisierung: Stra&szlig;enabschnitte </h4>
			</div>
		</div>
		<div id="chart" class="chart"></div>
		<div id="caption" class="caption">
			<b>Bitte einen Streckenabschnitt in der Karte (farbige Linien) anklicken um detailierte Informationen zu
				erhalten.</b>
		</div>
		<div id="legend" class="legend">
			<b>Kartenlegende</b><br>
			Streckenabschnitte werden wie folgt eingefärbt: <br>
			Anteil der &Uuml;berholenden unter Minimalabstand:
			<div id="colorbar" class="colorbar"> </div>
			ohne Messungen: <font color="#808080">grau</font>
		</div>
	</div>

	<script type="text/javascript">
		//			var criterion = "d_mean";
		// var criterion = "p_above";
		var criterion = "d_quartile";

		var hist_xa = 0.0;
		var hist_xb = 2.55;
		var hist_xb_extends_to_infinity = true;
		var hist_dx = 0.25;
		var hist_n = Math.ceil((hist_xb - hist_xa) / hist_dx);
		var selectedFeatures = [];

		function histogramLabels() {

			var labels = Array(hist_n);
			for (var i = 0; i < hist_n; i++) {
				var xa = hist_xa + hist_dx * i;
				var xb = xa + hist_dx;
				var xc = xa + 0.5 * hist_dx;
				if (hist_xb_extends_to_infinity &&  (i == hist_n - 1)){
					labels[i] = "≥" + (xa * 100).toFixed(0)
				} else {
					labels[i] = (xa * 100).toFixed(0) + "-" + (xb * 100).toFixed(0);
				}
			}

			return labels;
		}

		function histogramColors(palette) {

			var colors = Array(hist_n);
			for (var i = 0; i < hist_n; i++) {
				var xc = hist_xa + hist_dx * i;
				colors[i] = palette.rgb_hex(xc);
			}

			return colors;
		}

		function histogram(samples) {
			var binCounts = new Array(hist_n).fill(0);

			for (var i = 0; i < samples.length; i++) {
				var v = samples[i];
				var j = Math.floor((v - hist_xa) / hist_dx);
				if (hist_xb_extends_to_infinity){
					j = Math.min(j, hist_n - 1);
				}
				if (j >= 0 && j < hist_n) {
					binCounts[j]++;
				}
			}

			return binCounts;
		}
		function getMeasurements(features) {
			var m = [];
			features.forEach(feature => {
				m = m.concat(feature.get('distance_overtaker_measurements'));
			});
			m.sort((a, b) => a - b);
			return m;
		}
		function getStats(features) {
			var limit = 100;
			var m = getMeasurements(features);
			features.forEach(feature => {
				var l = feature.get('distance_overtaker_limit');
				if (l < limit) limit = l;
			});
			stats = {};
			stats.n = m.length;
			stats.median = m.length > 0 ? m[Math.floor(m.length/2)] : 0;
			stats.min = m.length > 0 ? m[0] : 0;
			stats.below = 0;
			stats.limit = limit;
			for (let i = 0; i < m.length && m[i] < limit; i++) stats.below++;
			return stats;
		}

		function annotation(features) {
			if (features.length == 0) {
				return "";
			}
			var stats = getStats(features);
			var feature = features[0];
			var s = "<table>";

			s += "<tr><td>Stra&szlig;enname:</td><td><a href=\"https://www.openstreetmap.org/way/" + feature.get('way_id') + "\" target=\"_blank\">" + feature.get('name')
				+ "</a></td></tr>";

			s += "<tr height=\"5em\"></tr>";

			var p = stats.below / stats.n * 100.0;
			s += "<tr><td>Unterschreitung Mindestabstand:</td><td>" + ((stats.n == 0) ? "n/a" : p.toFixed(1)) + "% der &Uuml;berholenden</td></tr>";

			var ticks = feature.get('ticks');
			if (ticks == 0) ticks = 1;
			var m = feature.get('distance_overtaker_measurements');
			var mean = 0;
			for (let i = 0; i < m.length; i++) {
				mean += m[i];
			}
			s += "<tr><td>Durchschnitt &Uuml;berholabstand:</td><td>" + ((m.length == 0) ? "n/a" : (mean / m.length).toFixed(2)) + " m </td></tr>";

			s += "<tr><td>Median &Uuml;berholabstand:</td><td>" + ((stats.median == 0) ? "n/a" : stats.median.toFixed(2)) + " m </td></tr>";

			s += "<tr><td>Minimum &Uuml;berholabstand:</td><td>" + ((m.length == 0) ? "n/a" : m[0].toFixed(2)) + " m </td></tr>";

			s += "<tr height=\"5em\"></tr>";

			s += "<tr><td>Mindest&uuml;berholabstand:</td><td>" + ((stats.limit == null) ? "n/a" : stats.limit.toFixed(2)) + " m </td>";

			s += "<tr><td>&Uuml;berholvorg&auml;nge pro Minute:</td><td>" + (m.length / ticks * 60).toFixed(1) + "</td></tr>";

			s += "<tr><td>Anzahl Messungen:</td><td>" + stats.n.toFixed(0) + "</td></tr>";

			s += "<tr><td>Dauer der Erfassung (min):</td><td>" + (ticks / 60).toFixed(1) + "</td></tr>";

			s += "</table>";

			return s;
		}

		function smoothStep(x, a, b) {
			var y = (x - a) / (b - a);
			return Math.max(0.0, Math.min(1.0, y));
		}

		function styleFunction(feature, resolution, active = false) {
			var m = feature.get('distance_overtaker_measurements');
			var zone = feature.get('zone');
			if (zone == "urban") {
				palette = paletteUrban;
			} else if (zone == "rural") {
				palette = paletteRural;
			} else {
				palette = paletteUrban;
			}

			var valid = feature.get('valid');

			var color = [0, 0, 0, 255];

			if (valid) {
				switch (criterion) {
					case "d_median":
						color = palette.rgba_css(m[Math.floor(m.length/2)])
						break;
					case "d_quartile":
						color = palette.rgba_css(m[Math.floor(m.length/4)])
						break;
					case "d_min":
						color = palette.rgba_css(m[0])
						break;
				}
			} else {
				color = [128, 128, 128, 255];
			}

			var width = (active ? 4.0 : 2.0); // * detail + 4 * mid + 200.0 / resolution * overview;

			var style = new ol.style.Style({
				stroke: new ol.style.Stroke({
					color: color,
					width: width,
				})
			});
			return style;
		}

		var map = new ol.Map({
			target: 'map',
			interactions : ol.interaction.defaults({doubleClickZoom :false}),
			layers: [
				new ol.layer.Tile({
				    className: "bw",
					source: new ol.source.OSM({
						crossOrigin: null,
						url: 'https://{a-c}.tile.openstreetmap.org/{z}/{x}/{y}.png'
					})
				})
			],
			view: new ol.View({
				center: ol.proj.fromLonLat([9.1798000, 48.7759000]),
	  			zoom: 13
			})
		});



		var dataSource = new ol.source.Vector({
			format: new ol.format.GeoJSON(),
			url: 'json/roads.json'
		})

		var vectorLayer = new ol.layer.Vector({
			source: dataSource,
			style: styleFunction
		});

		map.addLayer(vectorLayer);

		const changeListener = dataSource.once('change', function(event) {
    		if (dataSource.getState() == 'ready') {
				const extent = vectorLayer.getSource().getExtent();
				const mapSize = map.getSize();
				const overlay = document.getElementById("overlay");
				const marginLeft = overlay.offsetWidth + overlay.offsetLeft;
    			map.getView().fit(extent, {size: mapSize, padding: [0, 0, 0, marginLeft]});
			}
		});

		var histogramColorsRural = histogramColors(paletteRural).reverse();
		var histogramColorsUrban = histogramColors(paletteUrban).reverse();

		var chartOptions = {
			series: [{
				name: 'Überholende',
				data: Array(hist_n).fill(0)
			}],
			chart: {
				type: 'bar',
				height: 350,
				animations: {
					animateGradually: {
						enabled: false
					}
				}
			},
			plotOptions: {
				bar: {
					horizontal: false,
					columnWidth: '95%',
					endingShape: 'flat',
					distributed: true
				},
			},
			dataLabels: {
				enabled: true
			},
			stroke: {
				show: false,
			},
			xaxis: {
				title: {
					text: 'Überholabstand in Zentimeter'
				},
				categories: histogramLabels().reverse(),
			},
			yaxis: {
				title: {
					text: 'Anzahl Überholende'
				},
				labels: {
					show: false
				}
			},
			fill: {
				opacity: 1,
			},
			legend: {
				show: false
			},
			tooltip: {
				y: {
					formatter: function (val) {
						return val
					}
				}
			}
		};

		var chart = new ApexCharts(document.querySelector("#chart"), chartOptions);
		chart.render();

		map.on('singleclick', function (evt) {
			var lonlat = ol.proj.transform(evt.coordinate, 'EPSG:3857', 'EPSG:4326');
			var feature = vectorLayer.getSource().getClosestFeatureToCoordinate(evt.coordinate);
			var lonlat2 = ol.proj.transform(feature.getGeometry().flatCoordinates, 'EPSG:3857', 'EPSG:4326');
			var distance = ol.sphere.getDistance([lonlat[0], lonlat[1]], [lonlat2[0], lonlat2[1]]);
			var resolution = map.getView().getResolution();

			var zone = feature.get('zone');
			var colors = undefined;
			switch (zone) {
				case "urban":
					colors = histogramColorsUrban;
					break;
				case "rural":
					colors = histogramColorsRural;
					break;
				default:
					colors = histogramColorsUrban;
			}
			chart.updateOptions({
				colors: colors
			});
			var hist;
			var total = [];
			if (distance > 200) {
				vectorLayer.getSource().getFeatures().forEach(f => { total.push(f); });
				selectedFeatures.forEach(f => {
					f.setStyle(styleFunction(f, resolution, false));
				});
				hist = histogram(total).reverse();
				selectedFeatures = [];
			}
			else if (feature && !evt.originalEvent.shiftKey) {
				selectedFeatures.forEach(f => {
					f.setStyle(styleFunction(f, resolution, false));
				});
				var name = feature.values_.name;
				var total = [];
				selectedFeatures = [];
				vectorLayer.getSource().getFeatures().forEach(f => {
					if (f.values_.name == name) {
						f.setStyle(styleFunction(f, resolution, true));
						selectedFeatures.push(f);
					}
				});
			}
			else if (feature && dataSource.hasFeature(feature)) {

				if (selectedFeatures.includes(feature)) {
					selectedFeatures.splice(selectedFeatures.indexOf(feature), 1);
					feature.setStyle(styleFunction(feature, resolution, false));
				}
				else {
					feature.setStyle(styleFunction(feature, resolution, true));
					selectedFeatures.push(feature);
				}
			}
			caption.innerHTML = annotation(selectedFeatures);
			caption.style.alignItems = "flex-start";

			if (selectedFeatures.length > 0) total = selectedFeatures;
			hist = histogram(getMeasurements(total)).reverse();

			chart.updateSeries([{
				name: 'Überholende',
				data: hist,
			}]);

			noFeatureActive = false;

		});

		// palettePercentageInverted.writeLegend('colorbar', [0, 100.0], '%');
		palettePercentageZweirat.writeLegend('colorbar', [0, 100.0], '%');
	</script>
</body>

</html>
